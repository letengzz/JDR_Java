# 微服务基础

## 从单体架构到微服务架构的演进

### 单体架构

**通常来说，如果一个war包或者jar包里面包含一个应用的所有功能，则我们称这种架构为单体架构**。

通过使用SpringBoot，几乎可以很快速地开发一个高性能的单体应用，只需要启动一个服务端，我们整个项目就开始运行了，各项功能融于一体，开发起来也更加轻松。

但是随着我们项目的不断扩大，单体应用似乎显得有点乏力了。

随着越来越多的功能不断地加入到一个SpringBoot项目中，随着接口不断增加，整个系统就要在同一时间内响应更多类型的请求，显然，这种扩展方式是不可能无限使用下去的，总有一天，这个SpringBoot项目会庞大到运行缓慢。并且所有的功能如果都集成在单端上，那么所有的请求都会全部汇集到一台服务器上，对此服务器造成巨大压力。

![image-20220320174622739](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/Java/202303271136667.png)

传统单体架构应用随着项目规模的扩大，实际上会暴露越来越多的问题，尤其是一台服务器无法承受庞大的单体应用部署，并且单体应用的维护也会越来越困难，我们得寻找一种新的开发架构来解决这些问题了。

### 集群和垂直化

以商城系统为例。随着业务的发展，产品被越来越多的人使用，那么对于整个技术架构来说，可能会面临以下挑战：

- 用户量越来越大，网络访问量不断增大，导致后端服务器的负载越来越高。

- 用户量大了，产品需要满足不同用户的需求来留住用户，使得业务场景越来越多并且越来越复杂。

- 当服务器的负载越来越高的时候，如果不进行任何处理，用户在网站上操作的响应会越来越慢，甚至出现无法访问的情况，对于非常注重用户体验的互联网产品来说，这是无法容忍的。

- 业务的场景越多越复杂，意味着war包中的代码量会持续上升，并且各个业务代码之间的耦合度也会越来越高，后期的代码维护和版本发布涉及的测试和上线，也会很困那。举个最简单的例子，当你需要在库存模块里面添加一个方法时，带来的影响是需要把整个系统重新测试和部署，而当一个war包有几GB的大小时，部署的过程也是相当痛苦的。

因此，我们可以从两个方面进行**优化**：

1. 通过横向增加服务器，把单台机器变成多台机器的集群。

2. 按照业务的垂直领域进行拆分，减少业务的耦合度，以及降低单个war包带来的伸缩性困难问题。

![image.png](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/Java/202303271137910.png)

把商城系统按照业务维度进行了垂直拆分：用户子系统、库存子系统、商品子系统，每个子系统由不同的业务团队负责维护并且独立部署。同时，我们针对Tomcat服务器进行了集群部署，也就是把多台Tomcat服务器通过网络进行连接组合，形成一个整体对外提供服务。这样做的好处是能够在改变应用本身的前提下，通过增加服务器来进行水平扩容从而提升整个系统的吞吐量。

**注意**：针对数据库进行了垂直分库，主要是考虑到Tomcat服务器能够承载的流量大了之后，如果流量都传导到数据库上，会给数据库造成比较大的压力。

总体来说，数据库层面的拆分思想和业务系统的拆分思想是一样的，都是采用分而治之的思想。

### SOA

- 假设一个用户执行下单操作，系统的处理逻辑是先去库存子系统检杳商品的库存，只有在库存足够的情况下才会提交订单，那么这个检查库存的逻辑是放在订单子系统中还是库存子系统呢？在整个系统中，一定会存在非常多类似的共享业务的场景，这些业务场景的逻辑肯定会被重复创建，从而产生非常多冗余的业务代码，这些冗余代码的维护成本会随着时间的推移越来越高，能不能够把这些共享业务逻辑抽离出来形成可重用的服务呢？

- 在一个集团公司下有很多子公司，每个子公司都有自己的业务模式和信息沉淀，各个子公司之间不进行交互和共享。这个时候每个子公司虽然能够创造一定的价值，但是由于各个子公司之间信息不是互联互通的，彼此之间形成了信息孤岛，使得价值无法最大化。

基于这些问题，就引入了SOA (`Service-Oriented Architecture`) ，也就是**面向服务的架构**，从语义上说，它和面向过程、面向对象、面向组件的思想是一样的，都是一种软件组建及开发的方式。核心目标是把一些通用的、会被多个上层服务调用的共享业务提取成独立的基础服务。这些被提取出来的共享服务相对来说比较独立，并且可以重用。所以在SOA中，服务是最核心的抽象手段，业务被划分为一些粗粒度的业务服务和业务流程。

![image.png](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/Java/202303271137444.png)

提取出了用户服务、库存服务、商品服务等多个共享服务。在SOA中，会采用ESB （企业服务总线）来作为系统和服务之间的通信桥梁，ESB本身还提供服务地址的管理、不同系统之间的协议转化和数据格式转化等。调用端不需要关心目标服务的位置，从而使得服务之间的交互是动态的，这样做的好处是实现了服务的调用者和服务的提供者之间的高度解耦。

总的来说，SOA主要解决的问题是：

- 信息孤岛。

- 共享业务的重用。

### 微服务架构

业务系统实施服务化改造之后，原本共享的业务被拆分形成可复用的服务，可以在最大程度上避免共享业务的重复建设、资源连接瓶颈瓶颈等问题。

​       微服务就是这样一种解决方案，从名字上来看，**面向服务(SOA)和微服务本质上都是服务化思想的一种体现**。如果SOA是面向服务开发的思想的雏形，那么微服务就是针对可重用业务服务的更进一步优化，我们可以把SOA看成微服务的超集，一但服务规模扩大就意味着服务的构建、发布、运维的复杂度也会成倍增加，所以实施微服务的前提是软件交付链路及基础设施的成熟化。因此微服务并不是一个新的概念，他本质上是服务化思想的最佳实践方向。由于SOA和微服务两者的关注点不一样，造成了这两者有非常大的区别：

- SOA关注的是服务的重用性及解决信息孤岛问题。

- 微服务关注的是解耦，虽然解耦和可重用性从特定的角度来看是一样的，但本质上是有区别的，解耦是降低业务之间的耦合度，而重用性关注的是服务的复用。

- 微服务会更多地关注在DevOps的持续交付上，因为服务粒度细化之后使得开发运维变得更加重要，因此微服务与容器化技术的结合更加紧密。

![image.png](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/Java/202303271137018.png)

将每个具体的业务服务构成可独立运行的微服务，每个微服务只关注某个特定的功能，服务之间采用轻量级通信机制REST API进行通信。细心的读者会发现SOA中的服务和微服务架构中的服务粒度是一样的，不是说SOA是微服务的超集吗？其实我们可以把用户服务拆分的更细，比如用户注册服务、用户鉴权服务等。实际上，微服务到底要拆分到多大的粒度没有统一的标准，更多的时候是需要在粒度和团队之间找平衡的，微服务的粒度越小，服务独立性带来的好处就越多，但是管理大量的微服务也会越复杂。

## 微服务简介

> In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.

Martin Fowler在2014年提出了"微服务"架构，它是一种全新的架构风格。

微服务把一个庞大的单体应用拆分为一个个的小型服务，比如图书管理项目中，有登录、注册、添加、删除、搜索等功能，那么我们可以将这些功能单独做成一个个小型的SpringBoot项目，独立运行。

每个小型的微服务，都可以独立部署和升级，这样，就算整个系统崩溃，那么也只会影响一个服务的运行。

微服务之间使用HTTP进行数据交互，不再是单体应用内部交互了，虽然这样会显得更麻烦，但是带来的好处也是很直接的，甚至能突破语言限制，使用不同的编程语言进行微服务开发，只需要使用HTTP进行数据交互即可。

可以同时购买多台主机来分别部署这些微服务，这样，单机的压力就被分散到多台机器，并且每台机器的配置不一定需要太高，这样就能节省大量的成本，同时安全性也得到很大的保证。甚至同一个微服务可以同时存在多个，这样当其中一个服务器出现问题时，其他服务器也在运行同样的微服务，这样就可以保证一个微服务的高可用。

![image-20220322090754438](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/Java/202303271137603.png)


当然，这里只是简单的演示一下微服务架构，实际开发中肯定是比这个复杂得多的。

可见，采用微服务架构，更加能够应对当今时代下的种种考验，传统项目的开发模式，需要进行架构上的升级。

微服务应具有特点：

- 微服务是一种架构风格。
- 微服务把一个应用拆分为一组小型服务。
- 微服务每个服务运行在自己的进程内，也就是可独立部署和升级。
- 微服务的服务之间使用轻量级HTTP交互，一般使用Json交换数据。
- 服务围绕业务功能拆分。
- 可以由全自动部署机制独立部署。
- 去中心化，服务自治。服务可以使用不同的语言、不同的存储技术 。

优点的背后也存在着诸多的问题：

- 要实现微服务并不是说只需要简单地将项目进行拆分，我们还需要考虑对各个微服务进行管理、监控等，这样我们才能够及时地寻找和排查问题。因此微服务往往需要的是一整套解决方案，包括服务注册和发现、容灾处理、负载均衡、配置管理等。
- 它不像单体架构那种方便维护，由于部署在多个服务器，我们不得不去保证各个微服务能够稳定运行，在管理难度上肯定是高于传统单体应用的。
- 在分布式的环境下，单体应用的某些功能可能会变得比较麻烦，比如分布式事务。

## 微服务框架功能

微服务框架的功能主要体现在以下几个方面：

- **注册中心**：服务提供者和消费者，能够从注册中心注册和得到服务信息。

- **配置中心**：在微服务架构中设计服务较多需要对于配置文件统一管理。

- **服务链路追踪**：对于服务之间的负载调用，要能通过链路追踪，得到具体参与者，调用链路出现问题能够快速定位。

- **负载均衡**：服务调用服务会采用一定的负载均衡策略，来保证服务的高可用。
- **服务容错**：通过熔断、降级服务容错策略，对系统进行有效的保护，降级是在服务或依赖的服务异常时，返回保底数据，熔断是指依赖服务多次失效，则熔断器打开，不再尝试调用，直接返回降级信息。熔断后，定期探测依赖服务可用性，若恢复则恢复调用。
- **服务网关**：用户请求过载时进行限流、排队、过载保护、黑白名单、异常用户过滤拦截等都可以通过服务网关实现。
- **服务发布与回滚**：蓝绿部署、灰度、AB Test等发布策略，可快速回滚应用。
- **服务动态伸缩、容器化**：根据服务负载情况，可快速手动或自动进行节点增加和减少。
