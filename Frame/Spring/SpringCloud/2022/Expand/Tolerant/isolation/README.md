# 隔离

微服务系统A调用B，而B调用C，这时如果C出现故障，则此时调用B的大量线程资源阻塞，慢慢的B的线程数量持续增加直到CPU耗尽到100%，整体微服务不可用，这时就需要对不可用的服务进行隔离。

类似于系统的垂直拆分，就按照一定的规则将系统划分成多个服务模块，并且每个服务模块之间是互相独立的，不会存在强依赖的关系。如果某个拆分后的服务发生故障后，能够将故障产生的影响限制在某个具体的服务内，不会向其他服务扩散，自然也就不会对整体服务产生致命的影响。

服务调用关系：

![image.png](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/Java/202303301456380.png)

互联网行业常用的服务隔离方式有：线程池隔离和信号量隔离。

## 线程池隔离

线程池隔离是通过Java的线程池进行隔离，B服务调用C服务给予固定的线程数量比如12个线程，如果此时C服务宕机了就算大量的请求过来，调用C服务的接口只会占用12个线程不会占用其他工作线程资源，因此B服务就不会出现级联故障。

线程池隔离实际上就是对每个服务的远程调用单独开放线程池，只基于固定数量的线程池，这样即使在短时间内出现大量请求，由于没有线程可以分配，所以就不会导致资源耗尽了。

**线程池隔离原理**：

![image-20220328121932455](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/Java/202303311908505.png)

## 信号量隔离

信号量隔离是使用Semaphore类实现的，思想基本上与上面是相同的，也是限定指定的线程数量能够同时进行服务调用，当拿不到信号量的时候直接拒接因此不会出现超时占用其他工作线程的情况。但是它相对于线程池隔离，开销会更小一些，使用效果同样优秀，也支持超时等。

```java
Semaphore semaphore = new Semaphore(10,true);  
//获取信号量  
semaphore.acquire();  
//do something here  
//释放信号量  
semaphore.release();  
```

## 区别

线程池隔离针对不同的资源分别创建不同的线程池，不同服务调用都发生在不同的线程池中，在线程池排队、超时等阻塞情况时可以快速失败。线程池隔离的好处是隔离度比较高，可以针对某个资源的线程池去进行处理而不影响其它资源，但是代价就是线程上下文切换的 overhead 比较大，特别是对低延时的调用有比较大的影响。而信号量隔离非常轻量级，仅限制对某个资源调用的并发数，而不是显式地去创建线程池，所以 overhead 比较小，但是效果不错，也支持超时失败。

二者区别：

| 类别         | 线程池隔离                               | 信号量隔离             |
| ------------ | ---------------------------------------- | ---------------------- |
| 线程         | 与调用线程不同，使用的是线程池创建的线程 | 与调用线程相同         |
| 开销         | 排队，切换，调度等开销                   | 无线程切换性能更高     |
| 是否支持异步 | 支持                                     | 不支持                 |
| 是否支持超时 | 支持超时                                 | 支持超时               |
| 并发支持     | 支持通过线程池大小控制                   | 支持通过最大信号量控制 |
